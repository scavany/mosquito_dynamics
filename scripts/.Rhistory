mappingWU[which(mappingWU[,1]==7),]
mappinWU=na.spline(mappingWU)
mappinUW=na.spline(mappingUW)
mappinWU[which(mappinWU[,1]==7),]
mappingWU
na.spline(mappingWU)
mappinUW
mappingUW
mappingWU[616,]
mappingUW[616,]
mappingUW[615:617,]
rm(list=ls())
mappingUW = cbind(seq(1,100,0.1), NA)
mappingWU
mappingUW
mappingUW = cbind(seq(0,100,0.1), NA)
mappingWU = cbind(seq(0,10,0.001), NA)
mappingUW[which(mappingUW[,1]==0)]=0
mappingUW[which(mappingUW[,1]==100)]=10
mappingUW = cbind(seq(1,100,0.1), NA)
mappingUW = cbind(seq(0,100,0.1), NA)
mappingUW[which(mappingUW[,1]==0),2]=0
mappingUW[which(mappingUW[,1]==100),2]=10
mappingUW[which(mappingUW[,1]==61.5),2]=6.878
mappingWU[which(mappingWU[,1]==0),2]=0
mappingWU[which(mappingWU[,1]==10),2]=100
mappingWU[which(mappingWU[,1]==6.878),2]=61.5
mappingUW=na.spline(mappingUW)
mappingWU=na.spline(mappingWU)
plot(mappingUW)
plot(mappingWU)
mappingWU[which(mappingWU[,1]==7),]
mappingWU[which(mappingWU[,1]==7.662),]
mappingWU[which(mappingWU[,1]==7.547),]
mappingWU[7548,]
mappingWU[7436,]
mappingWU[7428,]
mappingWU[7287,]
mappingWU[7250,]
mappingWU[7220,]
mappingWU[7185,]
mappingWU[7178,]
mappingWU[7032,]
mappingWU[,2]=NA
mappingWU[,2]
mappingWU[which(mappingWU[,1]==0)]=0
mappingWU[which(mappingWU[,1]==10)]=100
mappingWU[which(mappingWU[,1]==6.886)]=100
mappingWU=na.spline(mappingWU)
mappingWU[,2]=NA
mappingWU[which(mappingWU[,1]==0),2]=0
mappingWU[which(mappingWU[,1]==10),2]=100
mappingWU[which(mappingWU[,1]==6.886),2]=61.5
mappingWU=na.spline(mappingWU)
mappingWU[7633]
mappingWU[7633,]
mappingWU
mappingWU[,2]=NA
mappingWU
mappingWU[,1]=seq(0,10,0.001)
mappingWU
mappingWU[which(mappingWU[,1]==0),2]=0
mappingWU[which(mappingWU[,1]==10),2]=100
mappingWU[which(mappingWU[,1]==6.886),2]=61.5
mappingWU[0]
mappingWU[0,]
mappingWU[1,]
mappingWU[10001,]
mappingWU[6887,]
mappingWU=na.spline(mappingWU)
mappingWU[7633,]
mappingWU[7594,]
mappingWU[7595,]
mappingWU[7663,]
mappingWU[7548,]
mappingWU[7436,]
mappingWU[7428,]
mappingWU[7287,]
mappingWU[7249,]
mappingWU[7250,]
mappingWU[7220,]
mappingWU[7185,]
mappingWU[7178,]
mappingWU[7032,]
library('devtools')
library('fitR')
library('coda')
data(SIR)
SIR$rPointObs()
SIR$rPointObs
rm(list = ls())
# Set your working directory to the scripts folder
library(here)
setwd(here())
setwd("/home/sean/Documents/zika_project/mosquito_dynamics/scripts/")
require(mgcv)
require(scam)
require(deSolve)
require(pspline)
library(doParallel)
if (!require("pacman")) install.packages("pacman")
pacman::p_load(dlnm,
mgcv,
scam,
mapproj,
maptools,
spatstat,
RgoogleMaps,
RColorBrewer,
plotrix,
rgdal,
rgeos,
ggplot2,
raster,
gridExtra,
splines,
zoo)
source('./generate_emergence_functions_with_early_stages.R')
source('response_curves.R')
#======================================================================================
# Load data -----------------
#======================================================================================
dvec = seq(as.Date("2000-01-01"),as.Date("2010-12-31"),by="1 day")
tvec = seq(as.Date("2000-01-01"),as.Date("2010-12-31"),by="1 day")
# tvec = seq(as.POSIXct("2000-01-01"),as.POSIXct("2010-12-31 23:00"),by="hours")
initial_date = as.Date("2000-01-01")
# Locations = read.csv("../data/locations_area_20140807.csv")
Locations = read.csv("../data/synthetic_locations.csv")
Locations_original = Locations
# House_area = mean(Locations_original$area[which(Locations_original$landuse=="HOUSE")])
proto_pac = 5
# ratios of mosquito productivity per landuse relative to Houses (Morrisson 2006)
LandUseRatios = c(0.03, 0.01, 0.09, 1, 0.09, 0.09, 0.05, 0.003, 0.09,0.3)
# Derived parameters
col.names = levels(Locations$landuse)
nlandusetypes = length(col.names)
colClasses = c(rep("numeric",nlandusetypes))
ProdR = read.table(text = "",
colClasses = colClasses,
col.names = col.names)  # table of landuseratios
ProdR[1,] = LandUseRatios
Houses = which(Locations$landuse=="HOUSE")
# Including the Productivity ratio as an array in the Locations file
ProdRatio = array(data = 0, dim = c(length(Locations[,1])))
for(i in 1:length(Locations[,1])){
type = Locations$landuse[i]
ProdRatio[i] = ProdR[,eval(type)]
}
# Takes area into consideration by dividing the area by the avg house area
# Houses are assumed to have an average House area
# Other locations can't be more than 2 times a house
# Locations$ProdRatioArea = ProdRatio * Locations$area /  House_area
# Locations$ProdRatioArea[which(Locations$landuse == "HOUSE")] = 1
# Locations$ProdRatioArea[which(Locations$ProdRatioArea > 2)] = 2
# Use any location to generate the trend:
SmallLocations = Locations[10000,]
#======================================================================================
# Read temperature specific for Iquitos ------
#======================================================================================
Iquitos.climate = read.csv('../data/Iquitos_Climate_Bobby.csv')
startIndex = which(Iquitos.climate$date == as.character(tvec[1]))
# temperature = Iquitos.climate$temperature_mean[startIndex:(startIndex + length(dvec)-1) ]
# temperature.max = Iquitos.climate$temperature_max[startIndex:(startIndex + length(dvec)-1) ]
temperature = c()
temperature.max = c()
temperature.min = c()
for (i in 1:length(dvec)){
temperature = c(temperature, rep(Iquitos.climate$temperature_mean[startIndex+i-1],length(tvec)/length(dvec)))
temperature.max = c(temperature.max, rep(Iquitos.climate$temperature_max[startIndex+i-1],length(tvec)/length(dvec)))
temperature.min = c(temperature.min, rep(Iquitos.climate$temperature_min[startIndex+i-1],length(tvec)/length(dvec)))
}
temp.mean = mean(temperature,na.rm = TRUE); temperature[is.na(temperature)] = temp.mean
temp.max.mean = mean(temperature.max,na.rm = TRUE); temperature.max[is.na(temperature.max)] = temp.max.mean
temp.min.mean = mean(temperature.min,na.rm = TRUE); temperature.min[is.na(temperature.min)] = temp.min.mean
sunexp = 0.1
water.temp.max = 15.03 + 0.27*temperature.min + 0.01*temperature.max^2 + 7.69*sunexp^2
water.temp.min = 5.02 - 1.36*sunexp + 0.81*temperature.min + 0.001*temperature.max^2
water.temp.mean = (water.temp.min + water.temp.max)/2
#======================================================================================
# obtain parameters governing death and development ------------
#======================================================================================
development_params = read.csv('../data/development_params.csv', sep = '\t', row.names=1)
mortality_thresholds = read.csv('../data/mortality_thresholds.csv', sep = '\t', row.names=1)
#Note that egg development is just used in the first time step, the full time series is estimated from the ODE system
egg_development_rate = calculate_development_rate_timeseries(development_params$eggs, water.temp.mean)*length(dvec)/length(tvec)
larval_development_rate = calculate_development_rate_timeseries(development_params$pupae, water.temp.mean)*length(dvec)/length(tvec)
pupal_development_rate = calculate_development_rate_timeseries(development_params$larvae, water.temp.mean)*length(dvec)/length(tvec)
gonotrophic_cycle_rate = calculate_development_rate_timeseries(development_params$adults, temperature)*length(dvec)/length(tvec)
egg_mortality = log(1/(1-calculate_mortality_rate_timeseries(mortality_thresholds$eggs, water.temp.max)*length(dvec)/length(tvec)))
#We need to somehow incorporate the density dependence of larval mortality,
#but for now, use pupal rate for larvae (T dependent parts are identical)
pupal_mortality = log(1/(1-calculate_mortality_rate_timeseries(mortality_thresholds$pupae, water.temp.max)*length(dvec)/length(tvec)))
larval_mortality = pupal_mortality
#DeathRate is adult mortality:
DeathRate = log(1/(1-calculate_adult_mortality_rate_timeseries(mortality_thresholds$adult, temperature.max)*length(dvec)/length(tvec)))
#======================================================================================
# Calculate Surface Space + Time for a small dataset --------
#======================================================================================
offsets = c("1.1","1.35","1.6","1.7","1.9", "2")
# small_abundance_surf = list()
o_f = offsets[6]
eval(parse(text = sprintf("load(\"EstimateSurface%s%s\")",o_f,".RData")))
XY = cbind(SmallLocations$xcor,SmallLocations$ycor)
daily_abundance_surf = Estimate.w.offset(XY,dvec,as.numeric(o_f))
normalized_daily_adults = exp(daily_abundance_surf[[1]])[1,]/exp(daily_abundance_surf[[1]])[1,1]
#Insert these into the midpoint of the day for the trend abundance surface
normalized_adults = rep(NA, length=length(tvec))
normalized_adults[seq(floor(length(tvec)/length(dvec)/2+1), length(tvec), length(tvec)/length(dvec))] <- normalized_daily_adults
adult_timeseries_trend = na.spline(normalized_adults)
# trend_abundance_surf = Estimate.w.offset.posix(XY,tvec,as.numeric(o_f)) # Log -- Est: [[1]] Std: [[2]]
# adult_timeseries_trend = exp(trend_abundance_surf[[1]])[1,]/exp(trend_abundance_surf[[1]])[1,1] #normalize by first timepoint to get non-location-specific trend
XYall = cbind(Locations$xcor, Locations$ycor)
log_initial_abundances = Estimate.w.offset(XYall,initial_date,as.numeric(o_f))
initial_abundances = proto_pac*exp(log_initial_abundances[[1]])[,1]
#Some of the new points are outside the old polygon - choose the nearest point and assign that initial abundance.
non_na_coordinates = which(!is.na(initial_abundances))
non_na_initial_abundances = initial_abundances[non_na_coordinates]
for (i in which(is.na(initial_abundances))){
distances = sqrt((Locations$xcor[non_na_coordinates] - Locations$xcor[i])^2 + (Locations$ycor[non_na_coordinates] - Locations$ycor[i])^2)
initial_abundances[i] = non_na_initial_abundances[which.min(distances)]
}
# Files needed:
# ../data/locations_20140807.csv
# ../data/Iquitos_Climate_Bobby.csv
# response_curves.R
# algam_85re.Rdata
# EstimateSurface[1.1,1.35,1.6,1.7,1.9.2].RData
#
#======================================================================================
# Load libraries and source files --------
#======================================================================================
rm(list = ls())
# Set your working directory to the scripts folder
library(here)
setwd(here())
setwd("/home/sean/Documents/zika_project/mosquito_dynamics/scripts/")
require(mgcv)
require(scam)
require(deSolve)
require(pspline)
library(doParallel)
if (!require("pacman")) install.packages("pacman")
pacman::p_load(dlnm,
mgcv,
scam,
mapproj,
maptools,
spatstat,
RgoogleMaps,
RColorBrewer,
plotrix,
rgdal,
rgeos,
ggplot2,
raster,
gridExtra,
splines,
zoo)
source('./generate_emergence_functions_with_early_stages_IMPLICIT.R')
source('response_curves.R')
#======================================================================================
# Load data -----------------
#======================================================================================
dvec = seq(as.Date("2000-01-01"),as.Date("2010-12-31"),by="1 day")
tvec = seq(as.Date("2000-01-01"),as.Date("2010-12-31"),by="1 day")
# tvec = seq(as.POSIXct("2000-01-01"),as.POSIXct("2010-12-31 23:00"),by="hours")
initial_date = as.Date("2000-01-01")
# Locations = read.csv("../data/locations_area_20140807.csv")
Locations = read.csv("../data/synthetic_locations.csv")
Locations_original = Locations
#======================================================================================
# Parameters ----------
#======================================================================================
proto_pac = 5
# ratios of mosquito productivity per landuse relative to Houses (Morrisson 2006)
LandUseRatios = c(0.03, 0.01, 0.09, 1, 0.09, 0.09, 0.05, 0.003, 0.09,0.3)
# Derived parameters
col.names = levels(Locations$landuse)
nlandusetypes = length(col.names)
colClasses = c(rep("numeric",nlandusetypes))
ProdR = read.table(text = "",
colClasses = colClasses,
col.names = col.names)  # table of landuseratios
ProdR[1,] = LandUseRatios
Houses = which(Locations$landuse=="HOUSE")
# Including the Productivity ratio as an array in the Locations file
ProdRatio = array(data = 0, dim = c(length(Locations[,1])))
for(i in 1:length(Locations[,1])){
type = Locations$landuse[i]
ProdRatio[i] = ProdR[,eval(type)]
}
# Use any location to generate the trend:
SmallLocations = Locations[10000,]
#======================================================================================
# Read temperature specific for Iquitos ------
#======================================================================================
Iquitos.climate = read.csv('../data/Iquitos_Climate_Bobby.csv')
startIndex = which(Iquitos.climate$date == as.character(tvec[1]))
# temperature = Iquitos.climate$temperature_mean[startIndex:(startIndex + length(dvec)-1) ]
# temperature.max = Iquitos.climate$temperature_max[startIndex:(startIndex + length(dvec)-1) ]
temperature = c()
temperature.max = c()
temperature.min = c()
for (i in 1:length(dvec)){
temperature = c(temperature, rep(Iquitos.climate$temperature_mean[startIndex+i-1],length(tvec)/length(dvec)))
temperature.max = c(temperature.max, rep(Iquitos.climate$temperature_max[startIndex+i-1],length(tvec)/length(dvec)))
temperature.min = c(temperature.min, rep(Iquitos.climate$temperature_min[startIndex+i-1],length(tvec)/length(dvec)))
}
temp.mean = mean(temperature,na.rm = TRUE); temperature[is.na(temperature)] = temp.mean
temp.max.mean = mean(temperature.max,na.rm = TRUE); temperature.max[is.na(temperature.max)] = temp.max.mean
temp.min.mean = mean(temperature.min,na.rm = TRUE); temperature.min[is.na(temperature.min)] = temp.min.mean
sunexp = 0.1
water.temp.max = 15.03 + 0.27*temperature.min + 0.01*temperature.max^2 + 7.69*sunexp^2
water.temp.min = 5.02 - 1.36*sunexp + 0.81*temperature.min + 0.001*temperature.max^2
water.temp.mean = (water.temp.min + water.temp.max)/2
#======================================================================================
# obtain parameters governing death and development ------------
#======================================================================================
development_params = read.csv('../data/development_params.csv', sep = '\t', row.names=1)
mortality_thresholds = read.csv('../data/mortality_thresholds.csv', sep = '\t', row.names=1)
#Note that egg development is just used in the first time step, the full time series is estimated from the ODE system
egg_development_rate = calculate_development_rate_timeseries(development_params$eggs, water.temp.mean)*length(dvec)/length(tvec)
larval_development_rate = calculate_development_rate_timeseries(development_params$pupae, water.temp.mean)*length(dvec)/length(tvec)
pupal_development_rate = calculate_development_rate_timeseries(development_params$larvae, water.temp.mean)*length(dvec)/length(tvec)
gonotrophic_cycle_rate = calculate_development_rate_timeseries(development_params$adults, temperature)*length(dvec)/length(tvec)
egg_mortality = log(1/(1-calculate_mortality_rate_timeseries(mortality_thresholds$eggs, water.temp.max)*length(dvec)/length(tvec)))
#We need to somehow incorporate the density dependence of larval mortality,
#but for now, use pupal rate for larvae (T dependent parts are identical)
pupal_mortality = log(1/(1-calculate_mortality_rate_timeseries(mortality_thresholds$pupae, water.temp.max)*length(dvec)/length(tvec)))
larval_mortality = pupal_mortality
#DeathRate is adult mortality:
DeathRate = log(1/(1-calculate_adult_mortality_rate_timeseries(mortality_thresholds$adult, temperature.max)*length(dvec)/length(tvec)))
#======================================================================================
# Calculate Surface Space + Time for a small dataset --------
#======================================================================================
offsets = c("1.1","1.35","1.6","1.7","1.9", "2")
# small_abundance_surf = list()
o_f = offsets[6]
eval(parse(text = sprintf("load(\"EstimateSurface%s%s\")",o_f,".RData")))
XY = cbind(SmallLocations$xcor,SmallLocations$ycor)
daily_abundance_surf = Estimate.w.offset(XY,dvec,as.numeric(o_f))
normalized_daily_adults = exp(daily_abundance_surf[[1]])[1,]/exp(daily_abundance_surf[[1]])[1,1]
#Insert these into the midpoint of the day for the trend abundance surface
normalized_adults = rep(NA, length=length(tvec))
normalized_adults[seq(floor(length(tvec)/length(dvec)/2+1), length(tvec), length(tvec)/length(dvec))] <- normalized_daily_adults
adult_timeseries_trend = na.spline(normalized_adults)
# trend_abundance_surf = Estimate.w.offset.posix(XY,tvec,as.numeric(o_f)) # Log -- Est: [[1]] Std: [[2]]
# adult_timeseries_trend = exp(trend_abundance_surf[[1]])[1,]/exp(trend_abundance_surf[[1]])[1,1] #normalize by first timepoint to get non-location-specific trend
XYall = cbind(Locations$xcor, Locations$ycor)
log_initial_abundances = Estimate.w.offset(XYall,initial_date,as.numeric(o_f))
initial_abundances = proto_pac*exp(log_initial_abundances[[1]])[,1]
#Some of the new points are outside the old polygon - choose the nearest point and assign that initial abundance.
non_na_coordinates = which(!is.na(initial_abundances))
non_na_initial_abundances = initial_abundances[non_na_coordinates]
for (i in which(is.na(initial_abundances))){
distances = sqrt((Locations$xcor[non_na_coordinates] - Locations$xcor[i])^2 + (Locations$ycor[non_na_coordinates] - Locations$ycor[i])^2)
initial_abundances[i] = non_na_initial_abundances[which.min(distances)]
}
Estimate.w.offset()
Estimate.w.offset
#=============================================================================
# Author: Guido Espana
# 25/10/2016
# Functions for Emergence Rates Generation
#
#=============================================================================
get_mortality_vector = function(time.in, temperature.in, fieldcorxn = 0.08969818){
death.temp = array(data = 0, dim = c(length(time.in)))
registerDoParallel(cores=4)
death.temp = foreach(t = 1:length(time.in), .combine = 'c') %dopar% {
death.temp[t] = mortalityRT(temperature.in[t],fieldcorxn) # Brady etal,2013
}
return(death.temp)
}
source('./generate_emergence_functions_with_early_stages_IMPLICIT.R')
#sprayed:
daily_abundance_surf.sprayed = Estimate.w.offset.sprayed(XY,dvec,as.numeric(o_f))
normalized_daily_adults = exp(daily_abundance_surf.sprayed[[1]])[1,]/exp(daily_abundance_surf.sprayed[[1]])[1,1]
normalized_adults = rep(NA, length=length(tvec))
normalized_adults[seq(floor(length(tvec)/length(dvec)/2+1), length(tvec), length(tvec)/length(dvec))] <- normalized_daily_adults
adult_timeseries_trend.sprayed = na.spline(normalized_adults)
log_initial_abundances = Estimate.w.offset.sprayed(XYall,initial_date,as.numeric(o_f))
initial_abundances.sprayed = proto_pac*exp(log_initial_abundances[[1]])[,1]
#Some of the new points are outside the old polygon - choose the nearest point and assign that initial abundance.
non_na_coordinates = which(!is.na(initial_abundances.sprayed))
non_na_initial_abundances = initial_abundances.sprayed[non_na_coordinates]
for (i in which(is.na(initial_abundances.sprayed))){
distances = sqrt((Locations$xcor[non_na_coordinates] - Locations$xcor[i])^2 + (Locations$ycor[non_na_coordinates] - Locations$ycor[i])^2)
initial_abundances.sprayed[i] = non_na_initial_abundances[which.min(distances)]
}
save(adult_timeseries_trend, initial_abundances, daily_abundance_surf,adult_timeseries_trend.sprayed, initial_abundances.sprayed, daily_abundance_surf.sprayed, file="early_surfaces.RData")
plot(adult_timeseries_trend.sprayed)
lines(adult_timeseries_trend, col='r')
lines(adult_timeseries_trend, col='red')
plot(adult_timeseries_trend.sprayed - adult_timeseries_trend)
plot(adult_timeseries_trend - adult_timeseries_trend.sprayed, type='l')
plot(adult_timeseries_trend[2900:3000] - adult_timeseries_trend.sprayed[2900:3000], type='l')
plot(adult_timeseries_trend[2900:3000], type='l')
plot(adult_timeseries_trend.sprayed[2900:3000], type='l', col='red')
plot(adult_timeseries_trend[2900:3000], type='l')
lines(adult_timeseries_trend.sprayed[2900:3000], type='l', col='red')
plot(adult_timeseries_trend, type='l')
plot(adult_timeseries_trend.sprayed, type='l', col='red')
plot(adult_timeseries_trend, type='l')
lines(adult_timeseries_trend.sprayed, type='l', col='red')
lines(adult_timeseries_trend - adult_timeseries_trend.sprayed, type='l', col='red')
plot(adult_timeseries_trend - adult_timeseries_trend.sprayed, type='l', col='red')
plot((adult_timeseries_trend - adult_timeseries_trend.sprayed)/adult_timeseries_trend, type='l', col='red')
plot(dvec, (adult_timeseries_trend - adult_timeseries_trend.sprayed)/adult_timeseries_trend, type='l', col='red')
dvec
which(dvec=="2004-01-01"
which(dvec=="2004-01-01")
which(dvec=="2004-12-31")
plot(dvec[1462:1827], ((adult_timeseries_trend - adult_timeseries_trend.sprayed)/adult_timeseries_trend)[1462:1827], type='l', col='red')
plot(dvec[1700:1850], ((adult_timeseries_trend - adult_timeseries_trend.sprayed)/adult_timeseries_trend)[1700:1850], type='l', col='red')
plot(dvec[1800:1850], ((adult_timeseries_trend - adult_timeseries_trend.sprayed)/adult_timeseries_trend)[1800:1850], type='l', col='red')
plot(dvec[1780:1850], ((adult_timeseries_trend - adult_timeseries_trend.sprayed)/adult_timeseries_trend)[1780:1850], type='l', col='red')
rbind(dvec[1780:1850],((adult_timeseries_trend - adult_timeseries_trend.sprayed)/adult_timeseries_trend)[1780:1850]
rbind(dvec[1780:1850],((adult_timeseries_trend - adult_timeseries_trend.sprayed)/adult_timeseries_trend)[1780:1850])
cbind(dvec[1780:1850],((adult_timeseries_trend - adult_timeseries_trend.sprayed)/adult_timeseries_trend)[1780:1850])
data.frame(dvec[1780:1850],((adult_timeseries_trend - adult_timeseries_trend.sprayed)/adult_timeseries_trend)[1780:1850])
data.frame('date'=dvec[1780:1850],'moz.diff'=((adult_timeseries_trend - adult_timeseries_trend.sprayed)/adult_timeseries_trend)[1780:1850])
moz.diff.df <- data.frame('date'=dvec[1780:1850],'moz.diff'=((adult_timeseries_trend - adult_timeseries_trend.sprayed)/adult_timeseries_trend)[1780:1850])
moz.diff.df[which(moz.diff.df$moz.diff<1e-10)]=0
moz.diff.df[,which(moz.diff.df$moz.diff<1e-10)]=0
moz.diff.df[,which(moz.diff.df$moz.diff<1e-10)]
moz.diff.df[which(moz.diff.df$moz.diff<1e-10)]
which(moz.diff.df$moz.diff<1e-10)
moz.diff.df[which(moz.diff.df$moz.diff<1e-10),2]
moz.diff.df[which(moz.diff.df$moz.diff<1e-10),2]=0
moz.diff.df
(adult_timeseries_trend - adult_timeseries_trend.sprayed)[1800]
(adult_timeseries_trend - adult_timeseries_trend.sprayed)[1810]
(adult_timeseries_trend - adult_timeseries_trend.sprayed)[1820]
(adult_timeseries_trend - adult_timeseries_trend.sprayed)[1830]
(adult_timeseries_trend - adult_timeseries_trend.sprayed)[1820]
dvec[1820]
dvec[1821]
initial_date
2004_spray_middle = dvec[1821]
spray_2004_mid = dvec[1821]
#======================================================================================
# Calculate Surface Space + Time for a small dataset --------
#======================================================================================
offsets = c("1.1","1.35","1.6","1.7","1.9", "2")
# small_abundance_surf = list()
o_f = offsets[6]
spray_2004_mid = dvec[1821]
log_spray_abundances = Estimate.w.offset(XYall,spray_2004_mid,as.numeric(o_f))
spray_abundances = proto_pac*exp(log_initial_abundances[[1]])[,1]
XYall = cbind(Locations$xcor, Locations$ycor)
log_initial_abundances = Estimate.w.offset(XYall,initial_date,as.numeric(o_f))
initial_abundances = proto_pac*exp(log_initial_abundances[[1]])[,1]
log_spray_abundances = Estimate.w.offset(XYall,spray_2004_mid,as.numeric(o_f))
spray_abundances = proto_pac*exp(log_initial_abundances[[1]])[,1]
#Some of the new points are outside the old polygon - choose the nearest point and assign that initial abundance.
non_na_coordinates = which(!is.na(initial_abundances))
non_na_initial_abundances = initial_abundances[non_na_coordinates]
non_na_spray_abundances = spray_abundances[non_na_coordinates]
for (i in which(is.na(initial_abundances))){
distances = sqrt((Locations$xcor[non_na_coordinates] - Locations$xcor[i])^2 + (Locations$ycor[non_na_coordinates] - Locations$ycor[i])^2)
initial_abundances[i] = non_na_initial_abundances[which.min(distances)]
spray_abundances[i] = non_na_spray_abundances[which.min(distances)]
}
log_initial_abundances = Estimate.w.offset.sprayed(XYall,initial_date,as.numeric(o_f))
initial_abundances.sprayed = proto_pac*exp(log_initial_abundances[[1]])[,1]
log_spray_abundances = Estimate.w.offset.sprayed(XYall,spray_2004_mid,as.numeric(o_f))
spray_abundances.sprayed = proto_pac*exp(log_initial_abundances[[1]])[,1]
#Some of the new points are outside the old polygon - choose the nearest point and assign that initial abundance.
non_na_coordinates = which(!is.na(initial_abundances.sprayed))
non_na_initial_abundances = initial_abundances.sprayed[non_na_coordinates]
non_na_spray_abundances = spray_abundances.sprayed[non_na_coordinates]
for (i in which(is.na(initial_abundances.sprayed))){
distances = sqrt((Locations$xcor[non_na_coordinates] - Locations$xcor[i])^2 + (Locations$ycor[non_na_coordinates] - Locations$ycor[i])^2)
initial_abundances.sprayed[i] = non_na_initial_abundances[which.min(distances)]
spray_abundances.sprayed[i] = non_na_spray_abundances[which.min(distances)]
}
initial_abundances - initial_abundances.sprayed
max(initial_abundances - initial_abundances.sprayed)
max(spray_abundances - spray_abundances.sprayed)
spray_abundances.sprayed
XYall = cbind(Locations$xcor, Locations$ycor)
log_initial_abundances = Estimate.w.offset(XYall,initial_date,as.numeric(o_f))
initial_abundances = proto_pac*exp(log_initial_abundances[[1]])[,1]
log_spray_abundances = Estimate.w.offset(XYall,spray_2004_mid,as.numeric(o_f))
spray_abundances = proto_pac*exp(log_spray_abundances[[1]])[,1]
#Some of the new points are outside the old polygon - choose the nearest point and assign that initial abundance.
non_na_coordinates = which(!is.na(initial_abundances))
non_na_initial_abundances = initial_abundances[non_na_coordinates]
non_na_spray_abundances = spray_abundances[non_na_coordinates]
for (i in which(is.na(initial_abundances))){
distances = sqrt((Locations$xcor[non_na_coordinates] - Locations$xcor[i])^2 + (Locations$ycor[non_na_coordinates] - Locations$ycor[i])^2)
initial_abundances[i] = non_na_initial_abundances[which.min(distances)]
spray_abundances[i] = non_na_spray_abundances[which.min(distances)]
}
log_initial_abundances = Estimate.w.offset.sprayed(XYall,initial_date,as.numeric(o_f))
initial_abundances.sprayed = proto_pac*exp(log_initial_abundances[[1]])[,1]
log_spray_abundances = Estimate.w.offset.sprayed(XYall,spray_2004_mid,as.numeric(o_f))
spray_abundances.sprayed = proto_pac*exp(log_spray_abundances[[1]])[,1]
#Some of the new points are outside the old polygon - choose the nearest point and assign that initial abundance.
non_na_coordinates = which(!is.na(initial_abundances.sprayed))
non_na_initial_abundances = initial_abundances.sprayed[non_na_coordinates]
non_na_spray_abundances = spray_abundances.sprayed[non_na_coordinates]
for (i in which(is.na(initial_abundances.sprayed))){
distances = sqrt((Locations$xcor[non_na_coordinates] - Locations$xcor[i])^2 + (Locations$ycor[non_na_coordinates] - Locations$ycor[i])^2)
initial_abundances.sprayed[i] = non_na_initial_abundances[which.min(distances)]
spray_abundances.sprayed[i] = non_na_spray_abundances[which.min(distances)]
}
max(initial_abundances - initial_abundances.sprayed)
max(spray_abundances - spray_abundances.sprayed)
spray_abundances - spray_abundances.sprayed
q()
